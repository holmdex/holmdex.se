---
title: "Weekday Market Patterns"
author: "Holmdex"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
format: 
  html:
    theme: cosmo
    toc: true
    toc-depth: 2
    code-fold: true
    embed-resources: true
    self-contained: true
---

```{r setup, include=FALSE}
# Load essential packages
suppressPackageStartupMessages({
  library(tidyverse)
  library(lubridate)
  library(plotly)
  library(knitr)
})

# Explicitly set dplyr functions to avoid namespace conflicts
filter <- dplyr::filter
select <- dplyr::select
group_by <- dplyr::group_by
summarize <- dplyr::summarize
mutate <- dplyr::mutate
arrange <- dplyr::arrange

# Try to load all potentially useful market data packages with improved error handling
required_packages <- c(
  "quantmod", "tidyquant", "httr", "jsonlite", 
  "rvest", "xml2", "TTR", "curl"
)

for(pkg in required_packages) {
  tryCatch({
    if(!requireNamespace(pkg, quietly = TRUE)) {
      install.packages(pkg, repos = "https://cloud.r-project.org")
    }
    library(pkg, character.only = TRUE)
  }, error = function(e) {
    message(paste("Note: Package", pkg, "could not be loaded:", e$message))
  })
}

# Set global options
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = FALSE)

# Set fixed time period for consistent analysis - 5 years of data but allow less if needed
end_date <- Sys.Date()
start_date <- end_date - years(5)

# Set minimum trading days requirement (approximately 1.5 years of trading)
# Less strict to ensure more regions are included
MIN_TRADING_DAYS <- 1000

# Set a minimum requirement for indices per region
# This ensures we have at least some representation for each region
MIN_INDICES_PER_REGION <- 1

# Set weekday coverage requirement - allow partial representation
MIN_WEEKDAY_COUNT <- 100  # At least 10 occurrences of each weekday needed
```

```{r get-market-data-function}
# Enhanced function to attempt many different methods to get market data
get_market_data <- function(symbol, start_date, end_date, retries = 5, timeout = 60) {
  price_data <- NULL
  temp_file <- NULL
  
  # Define an extensive list of realistic user agents
  user_agents <- c(
    # Chrome
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36",
    # Firefox
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0",
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:108.0) Gecko/20100101 Firefox/108.0",
    "Mozilla/5.0 (X11; Linux i686; rv:108.0) Gecko/20100101 Firefox/108.0",
    # Safari
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Safari/605.1.15",
    # Edge
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.76",
    # Mobile
    "Mozilla/5.0 (iPhone; CPU iPhone OS 16_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.1 Mobile/15E148 Safari/604.1",
    "Mozilla/5.0 (Linux; Android 13) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.5359.128 Mobile Safari/537.36"
  )
  
  # Define different accept headers
  accept_headers <- c(
    "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
    "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
    "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
  )
  
  # Define referer headers
  referer_headers <- c(
    "https://finance.yahoo.com/",
    "https://www.google.com/search?q=finance",
    "https://www.bing.com/search?q=stock+market",
    "https://www.investing.com/"
  )
  
  # Function to get random headers
  get_random_headers <- function() {
    list(
      "User-Agent" = sample(user_agents, 1),
      "Accept" = sample(accept_headers, 1),
      "Accept-Language" = "en-US,en;q=0.9",
      "Referer" = sample(referer_headers, 1),
      "Connection" = "keep-alive",
      "Upgrade-Insecure-Requests" = "1",
      "Sec-Fetch-Dest" = "document", 
      "Sec-Fetch-Mode" = "navigate",
      "Sec-Fetch-Site" = "cross-site"
    )
  }
# Retry mechanism with multiple methods
  for(retry in 1:retries) {
    if(!is.null(price_data)) break
    
    # Method 1: Try quantmod with Yahoo Finance
    if(is.null(price_data) && exists("getSymbols")) {
      tryCatch({
        options(timeout = timeout)
        ticker <- getSymbols(symbol, src = "yahoo", from = start_date, to = end_date, auto.assign = FALSE)
        
        if(!is.null(ticker) && nrow(ticker) > 0) {
          # Format data
          price_data <- data.frame(date = index(ticker), coredata(ticker))
          colnames(price_data) <- c("date", "open", "high", "low", "close", "volume", "adjusted")
          price_data$symbol <- symbol
          message(paste("Method 1 successful for", symbol))
          return(price_data)
        }
      }, error = function(e) {
        if(retry == retries) message(paste("Method 1 failed for", symbol, ":", e$message))
        NULL
      })
    }
    
    # Method 2: Try tidyquant
    if(is.null(price_data) && exists("tq_get")) {
      tryCatch({
        options(timeout = timeout)
        ticker_data <- tq_get(symbol, from = start_date, to = end_date, get = "stock.prices")
        
        if(!is.null(ticker_data) && nrow(ticker_data) > 0) {
          message(paste("Method 2 successful for", symbol))
          return(ticker_data)
        }
      }, error = function(e) {
        if(retry == retries) message(paste("Method 2 failed for", symbol, ":", e$message))
        NULL
      })
    }
    
    # Method 3: Try Yahoo Finance API directly with httr
    if(is.null(price_data) && requireNamespace("httr", quietly = TRUE)) {
      tryCatch({
        # Format dates for Yahoo (ensure they're UNIX timestamps)
        start_unix <- as.numeric(as.POSIXct(start_date))
        end_unix <- as.numeric(as.POSIXct(end_date))
        
        # Build URL
        url <- paste0(
          "https://query1.finance.yahoo.com/v7/finance/download/", 
          URLencode(symbol),
          "?period1=", start_unix,
          "&period2=", end_unix,
          "&interval=1d&events=history"
        )
        
        # Use randomized browser-like headers to avoid getting blocked
        headers <- get_random_headers()
        
        response <- httr::GET(url, httr::add_headers(.headers = unlist(headers)), httr::timeout(timeout))
        
        if(httr::status_code(response) == 200) {
          # Save to temp file
          temp_file <- tempfile(fileext = ".csv")
          writeBin(httr::content(response, "raw"), temp_file)
          
          if(file.exists(temp_file) && file.info(temp_file)$size > 0) {
            data <- read.csv(temp_file, stringsAsFactors = FALSE)
            unlink(temp_file)
            
            if(nrow(data) > 0) {
              # Process data
              price_data <- data %>%
                rename_all(tolower) %>%
                mutate(date = as.Date(date), symbol = symbol)
              
              # Handle column naming differences
              if("adj.close" %in% colnames(price_data)) {
                price_data <- price_data %>% rename(adjusted = adj.close)
              } else if("adjclose" %in% colnames(price_data)) {
                price_data <- price_data %>% rename(adjusted = adjclose)
              }
              
              message(paste("Method 3 successful for", symbol))
              return(price_data)
            }
          }
          if(file.exists(temp_file)) unlink(temp_file)
        }
      }, error = function(e) {
        if(retry == retries) message(paste("Method 3 failed for", symbol, ":", e$message))
        if(file.exists(temp_file)) unlink(temp_file)
        NULL
      })
    }
    
    # Method 4: Try Yahoo Finance API with different URL format and query parameters
    if(is.null(price_data) && requireNamespace("httr", quietly = TRUE)) {
      tryCatch({
        # Format dates for Yahoo
        start_unix <- as.numeric(as.POSIXct(start_date))
        end_unix <- as.numeric(as.POSIXct(end_date))
        
        # Build URL with interval query param
        url <- paste0(
          "https://query2.finance.yahoo.com/v7/finance/download/", 
          URLencode(symbol),
          "?period1=", start_unix,
          "&period2=", end_unix,
          "&interval=1d&events=history&includeAdjustedClose=true"
        )
        
        # Different user agent for this attempt
        headers <- get_random_headers()
        headers[["User-Agent"]] <- "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0"
        
        response <- httr::GET(url, httr::add_headers(.headers = unlist(headers)), httr::timeout(timeout))
        
        if(httr::status_code(response) == 200) {
          # Save to temp file
          temp_file <- tempfile(fileext = ".csv")
          writeBin(httr::content(response, "raw"), temp_file)
          
          if(file.exists(temp_file) && file.info(temp_file)$size > 0) {
            data <- read.csv(temp_file, stringsAsFactors = FALSE)
            unlink(temp_file)
            
            if(nrow(data) > 0) {
              price_data <- data %>%
                rename_all(tolower) %>%
                mutate(date = as.Date(date), symbol = symbol)
              
              # Handle column naming differences
              if("adj.close" %in% colnames(price_data)) {
                price_data <- price_data %>% rename(adjusted = adj.close)
              } else if("adjclose" %in% colnames(price_data)) {
                price_data <- price_data %>% rename(adjusted = adjclose)
              }
              
              message(paste("Method 4 successful for", symbol))
              return(price_data)
            }
          }
          if(file.exists(temp_file)) unlink(temp_file)
        }
      }, error = function(e) {
        if(retry == retries) message(paste("Method 4 failed for", symbol, ":", e$message))
        if(file.exists(temp_file)) unlink(temp_file)
        NULL
      })
    }
    
    # Method 5: Try curl library directly for Yahoo Finance data
    if(is.null(price_data) && requireNamespace("curl", quietly = TRUE)) {
      tryCatch({
        # Format dates for Yahoo
        start_unix <- as.numeric(as.POSIXct(start_date))
        end_unix <- as.numeric(as.POSIXct(end_date))
        
        # Build URL
        url <- paste0(
          "https://query1.finance.yahoo.com/v7/finance/download/", 
          URLencode(symbol),
          "?period1=", start_unix,
          "&period2=", end_unix,
          "&interval=1d&events=history"
        )
        
        # Set up curl handle with headers and options
        handle <- curl::new_handle()
        curl::handle_setheaders(handle,
          "User-Agent" = sample(user_agents, 1),
          "Accept" = sample(accept_headers, 1),
          "Referer" = sample(referer_headers, 1)
        )
        curl::handle_setopt(handle, timeout = timeout)
# Download to temp file
        temp_file <- tempfile(fileext = ".csv")
        curl::curl_download(url, temp_file, handle = handle)
        
        if(file.exists(temp_file) && file.info(temp_file)$size > 0) {
          data <- read.csv(temp_file, stringsAsFactors = FALSE)
          unlink(temp_file)
          
          if(nrow(data) > 0) {
            price_data <- data %>%
              rename_all(tolower) %>%
              mutate(date = as.Date(date), symbol = symbol)
            
            # Handle column naming differences
            if("adj.close" %in% colnames(price_data)) {
              price_data <- price_data %>% rename(adjusted = adj.close)
            } else if("adjclose" %in% colnames(price_data)) {
              price_data <- price_data %>% rename(adjusted = adjclose)
            }
            
            message(paste("Method 5 successful for", symbol))
            return(price_data)
          }
        }
        if(file.exists(temp_file)) unlink(temp_file)
      }, error = function(e) {
        if(retry == retries) message(paste("Method 5 failed for", symbol, ":", e$message))
        if(file.exists(temp_file)) unlink(temp_file)
        NULL
      })
    }
    
    # Method 6: Try Yahoo Finance JSON Chart API
    if(is.null(price_data) && requireNamespace("httr", quietly = TRUE) && requireNamespace("jsonlite", quietly = TRUE)) {
      tryCatch({
        # Build URL for the chart API
        url <- paste0(
          "https://query1.finance.yahoo.com/v8/finance/chart/", 
          URLencode(symbol),
          "?interval=1d&range=5y"
        )
        
        # Get random headers
        headers <- get_random_headers()
        
        # Use httr with randomized headers
        response <- httr::GET(url, httr::add_headers(.headers = unlist(headers)), httr::timeout(timeout))
        
        if(httr::status_code(response) == 200) {
          # Parse JSON response
          json_data <- jsonlite::fromJSON(httr::content(response, "text", encoding = "UTF-8"))
          
          # Extract price data
          if(!is.null(json_data$chart$result) && length(json_data$chart$result) > 0) {
            result <- json_data$chart$result[[1]]
            
            # Check if we have timestamp and close data
            if(!is.null(result$timestamp) && !is.null(result$indicators$quote[[1]]$close)) {
              dates <- as.Date(as.POSIXct(result$timestamp, origin = "1970-01-01"))
              closes <- result$indicators$quote[[1]]$close
              
              # Extract other price data if available
              opens <- result$indicators$quote[[1]]$open
              highs <- result$indicators$quote[[1]]$high
              lows <- result$indicators$quote[[1]]$low
              volumes <- result$indicators$quote[[1]]$volume
              
              # Get adjusted closes if available
              adjusted <- closes
              if(!is.null(result$indicators$adjclose)) {
                if(!is.null(result$indicators$adjclose[[1]]$adjclose)) {
                  adjusted <- result$indicators$adjclose[[1]]$adjclose
                }
              }
              
              # Create data frame
              price_data <- data.frame(
                date = dates,
                open = opens,
                high = highs,
                low = lows,
                close = closes,
                volume = volumes,
                adjusted = adjusted,
                symbol = symbol,
                stringsAsFactors = FALSE
              )
              
              # Filter to date range
              price_data <- price_data %>%
                filter(date >= start_date & date <= end_date)
              
              if(nrow(price_data) > 0) {
                message(paste("Method 6 successful for", symbol))
                return(price_data)
              }
            }
          }
        }
      }, error = function(e) {
        if(retry == retries) message(paste("Method 6 failed for", symbol, ":", e$message))
        NULL
      })
    }
    
    # Method 7: Try with alternative symbol formats
    if(is.null(price_data) && retry > 2) {
      alt_symbols <- c(
        gsub("\\^", "", symbol),                  # Remove caret
        gsub("=F", "", symbol),                   # Remove futures marker
        gsub("\\.", "-", symbol),                 # Replace dots with hyphens
        gsub("-", ".", symbol),                   # Replace hyphens with dots
        paste0(symbol, ".L"),                     # Add London suffix
        paste0(symbol, ".NX"),                    # Add Nordic exchange suffix
        paste0(symbol, ".DE"),                    # Add German exchange suffix
        paste0(gsub("\\^", "", symbol), ".US")    # No caret with US suffix
      )
      
      # Filter out the original symbol
      alt_symbols <- setdiff(alt_symbols, symbol)
      
      # Try each alternative symbol
      for(alt_symbol in alt_symbols) {
        message(paste("Trying alternative symbol:", alt_symbol))
        
        tryCatch({
          ticker <- getSymbols(alt_symbol, src = "yahoo", from = start_date, to = end_date, auto.assign = FALSE)
          
          if(!is.null(ticker) && nrow(ticker) > 0) {
            # Format data (but keep original symbol reference)
            price_data <- data.frame(date = index(ticker), coredata(ticker))
            colnames(price_data) <- c("date", "open", "high", "low", "close", "volume", "adjusted")
            price_data$symbol <- symbol  # Keep original symbol for consistency
            message(paste("Alternative symbol", alt_symbol, "successful for", symbol))
            return(price_data)
          }
        }, error = function(e) {
          # Just continue to next alternative
        })
      }
    }
    
    # Method 8: Try with a shorter time period (3 years)
    if(is.null(price_data) && retry > 3) {
      fallback_start_date <- end_date - years(3)
      message(paste("Trying 3-year fallback period for", symbol))
      
      tryCatch({
        ticker <- getSymbols(symbol, src = "yahoo", from = fallback_start_date, to = end_date, auto.assign = FALSE)
        
        if(!is.null(ticker) && nrow(ticker) > 0) {
          # Format data
          price_data <- data.frame(date = index(ticker), coredata(ticker))
          colnames(price_data) <- c("date", "open", "high", "low", "close", "volume", "adjusted")
          price_data$symbol <- symbol
          message(paste("3-year fallback successful for", symbol))
          return(price_data)
        }
      }, error = function(e) {
        message(paste("3-year fallback failed for", symbol))
        NULL
      })
    }
# Method 9: Try with an even shorter time period (1 year)
    if(is.null(price_data) && retry > 4) {
      fallback_start_date <- end_date - years(1)
      message(paste("Trying 1-year fallback period for", symbol))
      
      tryCatch({
        ticker <- getSymbols(symbol, src = "yahoo", from = fallback_start_date, to = end_date, auto.assign = FALSE)
        
        if(!is.null(ticker) && nrow(ticker) > 0) {
          # Format data
          price_data <- data.frame(date = index(ticker), coredata(ticker))
          colnames(price_data) <- c("date", "open", "high", "low", "close", "volume", "adjusted")
          price_data$symbol <- symbol
          message(paste("1-year fallback successful for", symbol))
          return(price_data)
        }
      }, error = function(e) {
        message(paste("1-year fallback failed for", symbol))
        NULL
      })
    }
    
    # Wait between retries with exponential backoff and jitter
    if(is.null(price_data) && retry < retries) {
      # Calculate backoff time with jitter
      backoff_time <- retry * 2 * (1 + runif(1, min = 0, max = 0.5))
      message(paste("Waiting", round(backoff_time, 1), "seconds before retry", retry + 1))
      Sys.sleep(backoff_time)
    }
  }
  
  # If all methods fail, return empty data frame with proper structure
  if(is.null(price_data)) {
    message(paste("All methods failed for", symbol))
    return(tibble(
      symbol = character(),
      date = as.Date(character()),
      close = numeric(),
      adjusted = numeric()
    ))
  }
  
  return(price_data)
}
```

```{r regional-weekday-stats}
# Calculate regional weekday statistics with proper equal weighting for indices within each region
# First, calculate mean return for each index by weekday
# Then aggregate to regional level with equal index weighting within each region
regional_weekday_stats <- market_data %>%
  # First calculate mean return for each index by weekday
  group_by(region, index_name, weekday) %>%
  summarize(
    index_mean_return = mean(winsorized_return, na.rm = TRUE),
    index_median_return = median(winsorized_return, na.rm = TRUE),
    index_positive_pct = sum(winsorized_return > 0, na.rm = TRUE) / n() * 100,
    index_days = n(),
    .groups = "drop"
  ) %>%
  # Filter to ensure sufficient data per weekday per index
  # This is now more relaxed - only require MIN_WEEKDAY_COUNT days per weekday
  filter(index_days >= MIN_WEEKDAY_COUNT) %>%
  # Then calculate regional averages with equal index weighting within each region
  group_by(region, weekday) %>%
  summarize(
    mean_return = mean(index_mean_return, na.rm = TRUE),  # Each index gets equal weight
    median_return = mean(index_median_return, na.rm = TRUE),
    positive_pct = mean(index_positive_pct, na.rm = TRUE),
    num_indices = n_distinct(index_name),  # Count how many indices in this region
    total_days = sum(index_days),
    # Add a column to show the weight given to each index (as percentage)
    index_weight_pct = 100 / num_indices,  # Each index within a region gets equal weight
    .groups = "drop"
  )

# Apply additional capping to regional statistics to fix the extreme values issue
regional_weekday_stats <- regional_weekday_stats %>%
  mutate(
    mean_return = ifelse(abs(mean_return) > MAX_REGIONAL_RETURN, 
                        sign(mean_return) * MAX_REGIONAL_RETURN, 
                        mean_return),
    median_return = ifelse(abs(median_return) > MAX_REGIONAL_RETURN, 
                          sign(median_return) * MAX_REGIONAL_RETURN, 
                          median_return)
  )

# Find best and worst weekday by region
region_best_worst <- regional_weekday_stats %>%
  # Group by region
  group_by(region) %>%
  # Count how many weekdays we have data for
  mutate(weekday_count = n_distinct(weekday)) %>%
  # Only include regions with data for all 5 weekdays when determining best/worst
  filter(weekday_count == 5) %>%
  summarize(
    best_day = weekday[which.max(mean_return)],
    worst_day = weekday[which.min(mean_return)],
    best_return = max(mean_return),
    worst_return = min(mean_return),
    num_indices = first(num_indices),  # Capture number of indices per region
    .groups = "drop"
  )
```

### Best and Worst Days by Region

The table below shows the best and worst performing weekdays for each region:

```{r best-worst-summary}
# Create a clean table of best/worst days by region
best_worst_table <- region_best_worst %>%
  mutate(
    best_day_text = paste0(weekday_emojis[as.character(best_day)], " ", best_day, " (", round(best_return, 2), "%)"),
    worst_day_text = paste0(weekday_emojis[as.character(worst_day)], " ", worst_day, " (", round(worst_return, 2), "%)"),
    region = factor(region, levels = names(sort(table(market_data$region), decreasing = TRUE))),
    indices_included = num_indices
  ) %>%
  arrange(region) %>%
  select(region, indices_included, best_day_text, worst_day_text)

# Add a caption explaining the minimum requirements
caption_text <- paste0(
  "Best and worst weekdays by region based on minimum requirements: ",
  "At least ", MIN_TRADING_DAYS, " trading days per index and ",
  "at least ", MIN_WEEKDAY_COUNT, " trading days per weekday"
)

# Display as a clean data table
DT::datatable(
  best_worst_table,
  colnames = c("Region", "Indices Included", "Best Day", "Worst Day"),
  options = list(
    pageLength = 15,
    dom = 't',
    ordering = FALSE
  ),
  caption = caption_text,
  rownames = FALSE,
  escape = FALSE
)
```

```{r define-market-indices, include=FALSE}
# This chunk contains the market indices definitions
# It's included here but hidden from the output
# Define market indices by geographical region with multiple ticker options
# Each primary index has alternative tickers to maximize chance of successful data retrieval

# North America region
north_america_tickers <- list(
  "S&P 500" = c("^GSPC", "SPY", "INX", "SP500", "ES=F"),
  "Dow Jones" = c("^DJI", "DIA", "INDU", "YM=F"),
  "Nasdaq" = c("^IXIC", "QQQ", "COMP", "ONEQ", "NQ=F"),
  "Russell 2000" = c("^RUT", "IWM", "RTY=F"),
  "S&P/TSX Composite" = c("^GSPTSE", "XIC.TO", "TSX", "^JX")
)

# Define weekday emojis for visualizations
weekday_emojis <- c("Mon" = "ðŸ˜´", "Tue" = "ðŸš€", "Wed" = "ðŸ“ˆ", "Thu" = "ðŸ’¼", "Fri" = "ðŸŽ‰")
```
